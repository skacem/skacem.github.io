---
layout: post
comments: true
title: "Plotting with Seaborn"
excerpt: "Seaborn provides a high-level interface to Matplotlib and is compatible with Pandas’ data structures. Given a pandas DataFrame and a specification of the plot to be created, seaborn automatically converts the data values into visual attributes, internally computes statistical transformations and decorates the plot with informative axis labels and legends. In other words, seaborn saves you all the effort you would normally need to put into creating figures with matplotlib."
author: "Skander Kacem"
tags: [Visualization, tutorial, Seaborn]
katex: true
preview_pic: /assets/0/seaborn.png
---

## Seaborn and the Python Visualization Landscape

The python visualization landscape is complex and can be overwhelming. How did it get there?  (see [Jake Vanderplas' talk](https://www.youtube.com/watch?v=FytuB8nFHPQ) at PyCon 2017)

<div class="imgcap">
<img src="/assets/3/landscape.png" style="zoom:100%;" />
<div class="thecap"> The Python Visualization Landscape by Jake Vanderplas (PyCon 2017)</div></div>

Yet when it comes to data science and machine learning, Seaborn is the definitive data visualization library.  

Seaborn provides a high-level interface to matplotlib and is compatible with pandas’ data structures. Given a pandas dataframe and a specification of the plot to be created, seaborn automatically converts the data values into visual attributes, internally computes statistical transformations and decorates the plot with informative axis labels and legends.  In other words, seaborn saves you all the work you normally have to do when using matplotlib.  And if you have already used matplotlib, you know how long it sometimes takes to modify even a small part of your plot.

Nevertheless, to take full advantage of both worlds: the high-level API of Seaborn and the deep customizability of matplotlib, it is worthwhile to have some knowledge of the concepts and functions of matplotlib.   
But before I cover some important concepts of matplotlib, I would first like to show you the aesthetic difference between the two libraries with a simple example.

## Seaborn vs. Matplotlib

This section serves as motivation to learn Seaborn. I will use the same random-walk example from Jake Vanderplas' book [1]. The same code with more comments can be found on the author's [github](https://jakevdp.github.io/PythonDataScienceHandbook/04.14-visualization-with-seaborn.html).

We start by importing the required python libraries. By convention, Seaborn is imported as `sns`.

```python
# imports
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
import seaborn as sns

# Notebook settings
# Global figure size
plt.rcParams['figure.figsize'] = 9, 4
```

```python
# Create random walk data:
rwlk = np.random.RandomState(123)
x = np.linspace(0, 10, 500)
y = np.cumsum(rwlk.randn(500, 6), 0)
```
```python
# Plot the data with Matplotlib defaults
plt.style.use('classic')
plt.plot(x, y)
plt.legend('ABCDEF', ncol=2, loc='upper left');
```
<div class="imgcap">
<img src="/assets/3/rndwlk_mpl.png" style="zoom:90%;" />
<div class="thecap">   <br> </div></div>

It's remarkable how similar it looks to Matlab. In this respect, Matplotlib has excelled. Not only does it have a Matlab-like interface, but the graphics are also very similar. In my opinion, this is one of the major points that made python so successful today. However, I have to admit that, although the diagrams are complete in terms of information, they are not very visually appealing. 

Let's plot the same data using seaborn with its default settings, to see what I mean.
```python
sns.set()
# same plotting code as above
plt.plot(x, y)
plt.legend('ABCDEF', ncol=2, loc='upper left');
```
<div class="imgcap">
<img src="/assets/3/rndwlk_sns.png" style="zoom:90%;" />
<div class="thecap"> <br> </div></div>

That looks much better, doesn't it? 

Before you read on, you might want to take a look at the Seaborn [gallery](https://seaborn.pydata.org/examples/index.html). It gives an insight into the different types of plots you can generate with Seaborn. The thing to note is the wide range of plots and especially the beautiful and professional look they have. In fact, when plotting with seaborn, you don't have to do the work twice, by that I mean, the plots you create during your exploratory data analysis could be used to communicate your findings to your stakeholders.  
A key to success in your role as a data scientist is the ability to effectively communicate your findings visually to a variety of audiences. At least, in a way that accommodates engineers and their desire for detail, while being understandable and simple for managers and different levels of leadership.   

## The Artist Layer

Matplotlib’s architecture consists of three tiers: Backend layer, Artist layer and the scripting layer. The Artist hierarchy is the middle layer of the matplotlib stack and it is the place where much of the heavy lifting happens.

<div class="imgcap">
<img src="/assets/3/anatomy.png" style="zoom:90%;" />
<div class="thecap"> Source: matplotlib.org </div></div>

Every single component from the above pictures is an `Artist` instance and can be accessed and modified with matplotlib. Therefore, if you want to learn how to customize your Seaborn charts, the artist is a good place to start.  

As you will see below, the Seaborn diagrams are usually very well designed and do not require any additional fine-tuning of the plots. In fact, you will be most productive if you focus only on Seaborn and leave the design of the artist instances to Seaborn.

However, before we go any further and to better understand how seaborn works, it is important to understand the concepts behind the following classes; also known as containers: Figure, Axes and Axis.

### Figure

This `Artist` class refers to the whole figure that you see. It is possible to have multiple sub-plots (Axes) in the same `Figure` object.

```python
# create a figure with 4 axes 
fig, ax = plt.subplots(nrows=2, ncols=2)
# Annotate the first subplot
ax[0, 0].annotate('This is an Axes', 
                  (0.5, 0.5), color='r', 
                  weight='bold', ha='center', 
                  va='center', size=14)
# Set the axis of the second axes to x = y = [0, 3]
ax[0, 1].axis([0,3, 0,3])
# Title of the figure
plt.suptitle('One Figure with Four Axes', fontsize=18);
```
<div class="imgcap">
<img src="/assets/3/1f4a.png" style="zoom:100%;" />
<div class="thecap"> <br></div></div>


### Axes
In the previous example, we plotted a `Figure` instance containing four `Axes` objects. `Axes` object refers to the region of the image with the data space. `Figure` can contain multiple Axes, but a given `Axes` can only be in one `Figure`. `Axes` contains two (or three in the case of 3D) `Axis` objects [2].

```python
print(fig.axes)
```
    [<AxesSubplot:>, <AxesSubplot:>, <AxesSubplot:>, <AxesSubplot:>]


### Axis
`Axis` instance refers to an actual axis (x-axis/y-axis) in a specific `Axes` object.

```python
# print the axis of the first axes from the above figure
print(ax[0, 1].axis())
```
    (0.0, 3.0, 0.0, 3.0)

Now that we have reviewed the basics of matplotlib's Artist layer, lets move on to seaborn plotting functions.

## Overview of Seaborn Plotting Functions

In seaborn, each plotting function is either a **Figure-level** function or an **Axes-level** function.  Grasping the difference between both functions is essential.  


### Axes-Level Functions

An Axes-level function makes self-contained plots and has no effect on the rest of the figure. They behave like most plotting functions in the `matplotlib.pyplot` namespace. They plot data onto a single `matplotlib.pyplot.Axes` object. Thus, they can coexist perfectly in an object-oriented matplotlib script.  

The following example illustrates how seaborn axes-level functions and matplotlib plots can coexist together, in the same picture.

```python
# we start by loading our dataset
penguins = sns.load_dataset('penguins')

# Then we create a figure with two axes using matplotlib
fig, axs = plt.subplots(1, 2, figsize=(8, 4), gridspec_kw=dict(width_ratios=[4, 3]))
# We use sns to generate the scatter plot on the first subplot
sns.scatterplot(data=penguins, x="flipper_length_mm", y="bill_length_mm", hue="species", ax=axs[0])

# Finally, we use matplotlib to create a bar chart on the second subplot
xy = dict(penguins['species'].value_counts())
axs[1].bar(xy.keys(), xy.values(), 
           color=['royalblue','darkseagreen','darkorange']);
```
<div class="imgcap">
<img src="/assets/3/peng1.png" style="zoom:110%;" />
<div class="thecap"> <br> </div></div>

I hope you now have a better understanding of what axis-level functions are and how they co-exist with Matplotlib plots.  
In the [Exploring Seaborn's Common Types of Plots][#id1] section, we will introduce the most important axis plots that every data scientist needs in their toolkit.

### Figure-Level Functions

Figure-level functions, on the other hand, control the entire figure. They create a new figure every time they are invoked and return a `FacetGrid` object that contains one or more subplots. 

Each figure-level function corresponds to several axes-level functions that serve similar purposes.

<div class="imgcap">
<img src="/assets/3/function_overview2.png" style="zoom:75%;" />
<div class="thecap"> Figure Adapted from seaborn.pydata.org </div></div>


For example, the `sns.displot()` function is the figure-level function for  kernel density estimates (kde).   
To draw a kde plot, on a figure-level, we do as follows:
```python
# We create a displot figure then we set kind="kde"
sns.displot(data=penguins, x="", hue="species", 
             multiple="stack", kind="kde")
```
<div class="imgcap">
<img src="/assets/3/kde.png" style="zoom:95%;" />
<div class="thecap">  </div></div>

To get such a visually appealing figure with Matplotlib, we need more than just one line of code. However, the most interesting thing about the figure-level functions is not the appearance of the figures, but rather the ability to draw multiple instances of the same plot on different subsets of data. Indeed, they are tailor-made for this use case --More about this in a later section.

## Exploring Seaborn’s Common Types of Plots

 In this section I will summarize the most basic plots using different data sets. As you will notice, all the functions listed below, are axes-level functions,  and this for two major reasons:

1. This type of plots can be easily integrated as a subplot into maplotlib figures.
2. I prefer to use the figure-level functions for more complex use cases. There will be more about that in a later section.  

Remember, however, that the same *figure* generated using an axis-level function can be obtained using the corresponding figure-level function.

 For a more extensive tutorial check [seaborn's official webpage](https://seaborn.pydata.org/tutorial.html).

### Bar Plots

The bar plot is perhaps the most common chart when it comes to visualizing categorical variables. It consists of plotting a set of bars, with their heights usually reflecting the mean value of the dependent variable.  
To illustrate this, we are going to use the [employee.csv](https://github.com/skacem/TIL/blob/main/data/employee.csv) dataset.

```python
# load data
df = pd.read_csv('data/employee.csv')
```

Seaborn comes with four default settings that allow you to set the size of the plot and customize your figure depending on the type of your presentation. Those are: `paper`, `notebook`, `talk`, and `poster`. The `notebook` style is the default. You can switch between those styles by using the command `sns.set_context()`.

```python
sns.set_context("notebook", rc={"figure.figsize": (10, 6)})
sns.barplot(x=df['Department'],
            y=df['Age'])
# change the limits of the y axis
plt.ylim(0, 45)
plt.title('Age pro Department');
```
<div class="imgcap">
<img src="/assets/3/bar.png" style="zoom:100%;" />
<div class="thecap">  </div></div>

We could also change the colour palette of the seaborn plots. Basically, seaborn has six variations of the matplotlib's colour palette:  `deep`, `muted`, `pastel`, `bright`, `dark`, and `colorblind`.  

In the next figure we are going to display a set of vertical bars with nested grouping by three variables:

```python
# plotting the chart
sns.barplot(x=df['Department'], y=df['Age'], 
            hue=df['BusinessTravel'], 
            palette='magma_r')
plt.title('Various Departments and their Business Travel Modes');
```
<div class="imgcap">
<img src="/assets/3/bar2.png" style="zoom:100%;" />
<div class="thecap">  </div></div>

### Count Plots
While `sns.barplot()` shows point estimates, along with the confidence intervals using bars for each category, `sns.countplot()` on the other hand displays the count of each category using bars.

```python
sns.countplot(df['EducationField'])
# Change the angles of the text on the x ticks
plt.xticks(rotation = 45)
```
<div class="imgcap">
<img src="/assets/3/count.png" style="zoom:100%;" />
<div class="thecap">  </div></div>

As for bar plots, we could also display a set of count bars with hue:
```python
# plotting a count plot with hue
sns.countplot(x=df['EducationField'],
              hue=df['Attrition'],
              palette='colorblind')
plt.xticks(rotation=30);
```
<div class="imgcap">
<img src="/assets/3/count2.png" style="zoom:100%;" />
<div class="thecap">  </div></div>

### Line Plots

The line plot in seaborn is more advanced than the usual line plots from matplotlib and other visualization libraries. By default, the plot aggregates over multiple `y` values at each value of `x` and shows an estimate of the central tendency and a confidence interval for the estimate.

We start by plotting a simple line plot:
```python
sns.lineplot(x=df['Department'],
             y=df['Age']);
```
<div class="imgcap">
<img src="/assets/3/line.png" style="zoom:100%;" />
<div class="thecap">  </div></div>

Let's now introduce a hue into our plot:

```python
plt.style.use('ggplot')
sns.lineplot(x=df['Department'],
             y=df['Age'],
             hue=df['EducationField'])
plt.legend(loc='lower center', title='Education Field')
plt.title('Avg Age of Employee in Each Department wrt Education Fields');
```
<div class="imgcap">
<img src="/assets/3/line3.png" style="zoom:100%;" />
<div class="thecap">  </div></div>

The computation of confidence intervals can take a lot of time, particularly when dealing with large datasets. It is possible to disable them, if not needed:

```python
sns.lineplot(x=df['Department'],
             y=df['Age'],
             hue=df['EducationField'],
             ci=None
             )
plt.legend(loc='lower center', title='Education Field');
```
<div class="imgcap">
<img src="/assets/3/line4.png" style="zoom:100%;" />
<div class="thecap">  </div></div>

### Scatter Plots

Scatter plots are commonly used to visualize bivariate data. They use dots to represent the values in a Cartesian coordinate system, with each coordinate representing one variable. We can add more dimensions to the plot by coding the dots, namely through modifying their colour, shape or/and size.  
In this section we are going to use the penguins dataset from above. It contains body measurement of three penguin species: Adelie, Gentoo and Chinstrap.   
```python
penguins = sns.load_dataset('penguins')
```

We start by visualizing the bill length as a function of the flipper length with the penguin species as hue. To better visualize the plot, we change some of the default settings of the "notebook" plot style.

```python
# use the tick style
sns.set_style('darkgrid')
# change the font and figure size of the notebook
sns.set_context("notebook", font_scale=1.3,
                rc={"figure.figsize": (10, 8)})
# s: size of the dots
sns.scatterplot(data=penguins, x="flipper_length_mm", 
                y="bill_length_mm", hue="species", s=60)
# set x and y labels
plt.xlabel("Flipper Length (mm)")
plt.ylabel("Bill Length (mm)");
```
<div class="imgcap">
<img src="/assets/3/scatter1.png" style="zoom:90%;" />
<div class="thecap">  </div></div>

We may add two more dimensions to our diagram. However, this is not recommended as the visualization can become rather confusing.
```python
markers = {'Male':'o', 'Female':'X'}
# change the font and figure size of the notebook
sns.set_context("notebook", font_scale=1.2,
                rc={"figure.figsize": (10, 8)})
sns.scatterplot( x="flipper_length_mm", y="bill_length_mm", 
                hue="species",  style='sex', size="body_mass_g",
                data=penguins, markers=markers, 
                sizes=(20,300), alpha=.5)
plt.legend(ncol=2, loc=4)
# set x and y labels
plt.xlabel("Flipper Length (mm)")
plt.ylabel("Bill Length (mm)");
```
<div class="imgcap">
<img src="/assets/3/scatter2.png" style="zoom:90%;" />
<div class="thecap">  </div></div>

Sometimes you have no choice but to use a figure-level function to display a simple plot. For the obvious reason that the legend is displayed outside the axes, particularly if the data is scattered over the entire plane, so that there is no optimal place left for it. In my experience, such a case occurs rarely, and in general it means that you are using the wrong visualization for the data in question.  
Let's however simulate such a case: Imagine that you want to plot the salaries as function of age, department and years at the company for all the employees in their 30s (Who want to da that?!). Your plot using axes-level function would look as follows:

```python
plt.rcParams["figure.figsize"] = 8, 5
plt.style.use('fivethirtyeight')
# Let's add a size element in the plot

sns.scatterplot(x=df['Age'],
                y=df['MonthlyRate'],
                hue=df['Department'],
                size=df['YearsAtCompany'],
                sizes=(20, 400),
                alpha=.3)
plt.xlim(29.5, 45.5)
plt.title('Age vs Monthly Rate');
```
<div class="imgcap">
<img src="/assets/3/emp1.png" style="zoom:90%;" />
<div class="thecap">  </div></div>
As you can see, a lot of information is lost due to the legend, and you definitely can't remove it. One quick solution would be to use the corresponting figure-level function. That is, in the case of a scatter plot: `sns.relplot(**kargs, kind="scatter")`.
```python
sns.relplot(x=df['Age'],
            y=df['MonthlyRate'],
            hue=df['Department'],
            size=df['YearsAtCompany'],
            sizes=(20, 200),
            alpha=.3, kind="scatter",
            height=5, aspect=8/5
           )
plt.xlim(29.5, 45.5)
plt.title('Age vs Monthly Rate');
```
<div class="imgcap">
<img src="/assets/3/em2.png" style="zoom:90%;" />
<div class="thecap">  </div></div>

### Heat Maps

A heatmap is a two-dimensional graphical representation of data where the individual values that are contained in a matrix are represented as colors. The heatmap is very useful when it comes to displaying pairwise correlations between every feature of a dataframe. To illustrate this we will load in another pandas data frame example from seaborn for the  survival status of individual passengers on the Titanic.
```python
titanic = sns.load_dataset('titanic')
# Heat map with seaborn
sns.heatmap(titanic.corr(),  annot=True, cmap='GnBu');
```
<div class="imgcap">
<img src="/assets/3/heat1.png" style="zoom:90%;" />
<div class="thecap">  </div></div>

Heat maps are also very useful when it comes to missing data. It is often easier to leave them out and continue working with the remaining data. I think useful information can be found in the reasons for the dropouts, and it is often worth looking at them more closely. In fact, they often provide a better understanding of how the data was collected, and may help reveal certain patterns.  
Let's take a look at the missing data in the `titanic` dataframe:
```python
sns.heatmap(titanic.isnull(),yticklabels=False,cbar=False,cmap='YlOrRd');
```
<div class="imgcap">
<img src="/assets/3/heat2.png" style="zoom:90%;" />
<div class="thecap">  </div></div>

The red dashes represent missing values.  
If you want more insight about the missing data you have, consider installing the `missingno` library. It does just that and works flawlessly on top of seaborn and matplotlib.
### Histograms

Histograms are another important type of visualization that is widely to analyze the distribution of a variable.  
They provide information about the central tendency, the dispersion and the shape of a variable and can help identify outliers and other anomalies in your data.   
Histograms in seaborn are plotted with `sns.histplot()` and it comes with several advanced features. 

To plot the flipper length distribution of all penguins along the x axis:

```python
sns.histplot(data=penguins, x="flipper_length_mm");
```
<div class="imgcap">
<img src="/assets/3/hist1.png" style="zoom:90%;" />
<div class="thecap">  </div></div>

We can also define the total number of bins and add a kernel density estimate to smooth the histogram and provide more information about the shape of the distribution.
```python
sns.histplot(data=penguins, x="flipper_length_mm", 
             kde=True, color='red', bins=15);
```
<div class="imgcap">
<img src="/assets/3/hist2.png" style="zoom:90%;" />
<div class="thecap">  </div></div>

You can plot multiple histograms on the same axes using hue mapping:
```python
sns.histplot(data=penguins, x="flipper_length_mm", hue="species");
```
<div class="imgcap">
<img src="/assets/3/hist3.png" style="zoom:90%;" />
<div class="thecap">  </div></div>

Overlapping bars can be hard to visualize. An alternative approach would be to plot a step function.
```python
sns.histplot(data=penguins, x="flipper_length_mm", hue="species", element="step);
```
<div class="imgcap">
<img src="/assets/3/hist4.png" style="zoom:90%;" />
<div class="thecap">  </div></div>
As you can see, seaborn automatically set an alpha value to the plot, to make it more readable.  
If you have variables that differ substantially in size (as in the `tips` dataset),  use indepdendent density normalization:

```python
sns.histplot(
    tips, x="total_bill", hue="day", multiple="stack",
    stat="density", common_norm=False,
    palette='pastel'
);
```
<div class="imgcap">
<img src="/assets/3/hist5.png" style="zoom:90%;" />
<div class="thecap">  </div></div>
I will stop here, however there is much more you can do with the histogram function from seaborn. You can find a more detailed tutorial on histograms under the following [link](https://seaborn.pydata.org/generated/seaborn.histplot.html).

### Box Plots
Box plots allow to visually assess a lot of information and in a very compact way. They  usually show the central tendency, the amount of variation in the data as well as the presence of gaps, outliers or unusual data points. That makes them perfect when it comes to comparing the the underlying probability distribution between several variables.
First let's load the `tips` dataset. Seaborn includes 18 datasets, that you can easily load as pandas dataframe  using the `sns.load_dataset()` function. You can list all the available datasets using  `sns.get_dataset_names()`. 

```python
tips = sns.load_dataset('tips')
```
This dataset captures the amount of tips in a restaurant as a function of a number of factors, including total bill, day of the week, whether the person was a smoker, and so on.  

The next code shows how to generate a box plot with hue.
```python
sns.boxplot(x="day", y="total_bill", 
            data=tips, 
            hue="smoker",
            palette='coolwarm');
```
<div class="imgcap">
<img src="/assets/3/box.png" style="zoom:90%;" />
<div class="thecap">  </div></div>

Box plots were originally introduced and popularised by the American mathematician John Wilder Turkey more than 40 years ago. They were designed to be calculated and drawn by hand. As statistics are now being performed by computers, it has become much easier to create more complex variations of this plot such as: 

* [Bean plots](https://cran.r-project.org/web/packages/beanplot/vignettes/beanplot.pdf)
* [Violin plots](https://blog.bioturing.com/2018/05/16/5-reasons-you-should-use-a-violin-graph/)
* [Letter-value plots](http://vita.had.co.nz/papers/letter-value-plot.html)

These variations attempt to convey more information about the distribution, while maintaining the compact size of the box plots. 

## Exploring Seaborn’s Advanced Types of Plots

### Letter-Value Plots: Boxplots for Large Data


> Conventional boxplots are useful displays for conveying rough information about the central 50% and the extent of data. For small-sized data sets (n < 200), detailed estimates of tail behavior beyond the quartiles may not be trustworthy, so the information provided by boxplots is appropriately somewhat vague beyond the quartiles, and the expected number of "outliers" of size n is often less than 10. Larger data sets (n ~ 10,000-100,000) afford more precise estimates of quantiles beyond the quartiles, but conventional boxplots do not show this information about the tails, and, in addition, show large numbers of extreme, but not unexpected, observations. -- Heike Hofmann [6]

The letter-value plots, also known as "boxenplots" provide a better representation of the distribution of the data than the usual box plots, particularly when the data consists of more than 10,000 observations with many outliers.   

To clearly illustrate the benefits of this type of plot we will be using the diamond dataset from seaborn since it contains over 50,000 observations.
```python
# load the diamonds dataframe
diamonds = sns.load_dataset('diamonds')
# use a matplotlib style
plt.style.use('fivethirtyeight')
# clarity ranking
clarity_ranking = ["I1", "SI2", "SI1", "VS2", "VS1", "VVS2", "VVS1", "IF"]
sns.boxenplot(x="clarity", y="carat",
              color="b", order=clarity_ranking,
              scale="linear", data=diamonds,
             palette='RdBu');
```
<div class="imgcap">
<img src="/assets/3/boxen.png" style="zoom:85%;" />
<div class="thecap">  </div></div>

As reference here is what we get with a boxplot.
```python
sns.boxplot(x="clarity", y="carat",
            color="b", 
            order=clarity_ranking, 
            data=diamonds,
            palette='RdBu')
```
<div class="imgcap">
<img src="/assets/3/boxen2.png" style="zoom:85%;" />
<div class="thecap">  </div></div>
## TBC
To be continued :)

## Drafts
The core feature of Seaborn is to provide high-level commands to create, with less boilerplate code, a variety of chart types that are useful for both exploratory as well as explanatory data visualization. 

There are nearly 30 built-in styles in matplotlib that can be activated with the `plt.style.use()` function and can instantly give your Seaborn plots another appearance. Some of them are already integrated in seaborn



## References

[1] VanderPlas, Jake. 2016. Python Data Science Handbook. O’Reilly Media, Inc.  
[2] [Matplotlib - Axes Class](https://www.tutorialspoint.com/matplotlib/matplotlib_axes_class.htm)  
[3] Desai, Meet. [“Matplotlib + Seaborn + Pandas”](towardsdatascience.com/matplotlib-seaborn-pandas-an-ideal-amalgamation-for-statistical-data-visualisation-f619c8e8baa3.) Medium, Towards Data Science, 30 Oct. 2019  
[4] Waskom, M. L., (2021). seaborn: statistical data visualization. Journal of Open Source Software, 6(60), 3021, https://doi.org/10.21105/joss.03021  
[5] Gureckis, Todd. 2020. [Lab in Cognition and Perception](http://gureckislab.org/courses/spring20/labincp/intro)  
[6] Heike Hofmann, Hadley Wickham & Karen Kafadar (2017) Letter-Value Plots: Boxplots for Large Data, Journal of Computational and Graphical Statistics, 26:3, 469-477, DOI: 10.1080/10618600.2017.1305277