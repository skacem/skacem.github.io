---
layout: post
category: ml
comments: true
title: "The Least Squares Method"
excerpt: "The least squares method finds the best-fitting line through data by minimizing squared errors. It is the foundation of linear regression and machine learning. Instead of memorizing formulas, we'll in this post discover the solution by working backwards from what we want to achieve. This approach applies far beyond least squares."
author: "Skander Kacem"
tags:
  - Machine Learning
  - Linear Regression
  - Math
katex: true
preview_pic: /assets/0/svd.png
---
The least squares method finds the best-fitting line through data by minimizing squared errors - the foundation of linear regression and machine learning. Instead of memorizing formulas, we'll discover the solution by working backwards from what we want to achieve.

## Begin with the End in Mind: A Mathematical Approach

Stephen Covey wrote about "beginning with the end in mind" as a principle for life planning. The same idea applies to solving mathematical problems: start with what you want to achieve and ask "What conditions would make this true?"

For simple calculus problems, everyone does this automatically. To find the minimum of f(x), solve f'(x) = 0. Easy.

But when problems get complex, where no textbook has your exact setup, we often forget this approach. Imagine designing a communication system to maximize signal-to-noise ratio with constraints on power and bandwidth. No formula exists. So you ask: "What would make SNR maximal? What must be true about my filter coefficients at that maximum?" Work through those conditions, and you've derived your answer.

The backward-working method is powerful when problems get unfamiliar. (I'm grateful to Professor Holger Boche and Dr. Andreas Kortke at Heinrich Heine Institut for teaching me this way of thinking.)

That's exactly what we'll do here: start with what we want (minimize the error) and work backwards to discover the normal equations.

## Why Do We Need This?

Imagine measuring temperature vs. ice cream sales. You have 100 data points but want only 2 parameters: slope and intercept. You have 100 equations but only 2 unknowns. No single line passes through all points perfectly.

Least squares finds the line that gets as close as possible to all points by minimizing the total distance.

## A Note on Norms: Why Our Choice Matters

Before we dive into the mathematics, we need to address something fundamental: what does "minimize the distance" actually mean?

Distance can be measured in different ways. Each choice leads to a completely different problem with different solutions:

**||r||₁ (L1 norm)** = |r₁| + |r₂| + ... + |rₙ|
Sum of absolute errors. Leads to **linear programming**. Solutions tend to be sparse (many zeros). Robust to outliers. Used in LASSO regression and compressed sensing.

**||r||₂ (L2 norm)** = √(r₁² + r₂² + ... + rₙ²)
Euclidean distance. Leads to **least squares**. Solutions are smooth and unique. Has closed-form solution. Optimal when errors are Gaussian. **This is what we'll use.**

**||r||∞ (L∞ norm)** = max(|r₁|, |r₂|, ..., |rₙ|)
Maximum absolute error. Leads to **Chebyshev approximation**. Minimizes worst-case error. Used when you need to bound peak deviations.

We choose the 2-norm because:
1. It's differentiable everywhere (enables calculus-based optimization)
2. Leads to a linear system with closed-form solution
3. Has strong statistical justification (maximum likelihood under Gaussian noise)
4. Results in orthogonal projection (elegant geometry)

Everything that follows depends on this choice. With L1, you'd need linear programming. With L∞, you'd use minimax optimization. The 2-norm gives us the cleanest path.

## The Problem Setup

Now let's translate our intuition into mathematics. We have:
- A matrix **A** ∈ ℝ^(m×n) representing our system
- A measured vector **b** ∈ ℝ^m containing our observations
- m = number of measurements (equations)
- n = number of parameters to estimate (unknowns)
- The key: m > n (more equations than unknowns)

Think of **A** as encoding the relationship between parameters and measurements. Each row of **A** corresponds to one measurement. The vector **b** holds what we actually observed.

Our goal: find **x**\* such that:

$$
\| \mathbf{A}\mathbf{x}^* - \mathbf{b} \|_2 = \min_{\mathbf{x}\in\mathbb{R}^n} \| \mathbf{A}\mathbf{x} - \mathbf{b}\|_2 \tag{1}
$$

The vector **r** = **Ax** - **b** is the **residual**: how far off our approximation is from reality. We want to make this as small as possible.

## Deriving the Normal Equations

Here's where the backward-working method pays off. We want to minimize equation (1). What condition must hold at the minimum? 

The gradient must equal zero. That single insight unlocks everything.

Let's work through it. Minimizing the 2-norm is the same as minimizing its square (since square root is monotonic):

$$
f(\mathbf{x}) = \| \mathbf{A}\mathbf{x} - \mathbf{b}\|_2^2 = (\mathbf{A}\mathbf{x} - \mathbf{b})^T(\mathbf{A}\mathbf{x} - \mathbf{b})
$$

Expanding this product:

$$
f(\mathbf{x}) = \mathbf{x}^T\mathbf{A}^T\mathbf{A}\mathbf{x} - 2\mathbf{b}^T\mathbf{A}\mathbf{x} + \mathbf{b}^T\mathbf{b}
$$

Now take the gradient with respect to **x**:

$$
\nabla f(\mathbf{x}) = 2\mathbf{A}^T\mathbf{A}\mathbf{x} - 2\mathbf{A}^T\mathbf{b}
$$

Set it to zero:

$$
2\mathbf{A}^T\mathbf{A}\mathbf{x} - 2\mathbf{A}^T\mathbf{b} = 0
$$

Divide by 2 and we get the **normal equations**:

$$
\mathbf{A}^T\mathbf{A}\mathbf{x} = \mathbf{A}^T\mathbf{b} \tag{2}
$$

We discovered this by asking "what must be true at the minimum?" The residual **r** = **Ax** - **b** is orthogonal to the column space of **A** at the optimal solution. We're projecting **b** onto the space spanned by **A**'s columns.

## When Does a Solution Exist?

Great, we have the normal equations. But can we always solve them? And if so, is the solution unique?

The good news: the normal equations always have at least one solution. But the character of that solution depends entirely on the rank of **A**.

### Case 1: Full Rank (rank(A) = n)

When **A** has full column rank, something nice happens. The matrix **A**^T**A** is:
- Symmetric (obviously: (**A**^T**A**)^T = **A**^T**A**)
- Positive definite (since **x**^T**A**^T**A**x** = ||**Ax**||² > 0 for **x** ≠ 0)

This means (**A**^T**A**)^(-1) exists and is unique. We can directly solve for **x**:

$$
\mathbf{x}^* = (\mathbf{A}^T\mathbf{A})^{-1}\mathbf{A}^T\mathbf{b} \tag{3}
$$

One matrix, one solution. Clean and simple.

### Case 2: Rank Deficient (rank(A) < min(m,n))

Now things get interesting. When **A** lacks full rank, **A**^T**A** becomes singular. It has no inverse. Multiple solutions exist that all minimize the residual equally well.

Which one do we choose? The convention is to pick the solution with smallest norm:

$$
\mathbf{x}^* = \underset{\mathbf{x} \in X}{\text{argmin}} \|\mathbf{x}\|
$$

where X is the set of all solutions to the normal equations.

This is where we need a more sophisticated tool: the pseudoinverse.

## The Pseudoinverse

Look at equation (3) again. That term (**A**^T**A**)^(-1)**A**^T shows up constantly in statistics, signal processing, and machine learning. We give it a special name: the **pseudoinverse** of **A**, written **A**^†:

$$
\mathbf{A}^\dagger = (\mathbf{A}^T\mathbf{A})^{-1}\mathbf{A}^T
$$

Think of the pseudoinverse as "the closest thing to an inverse" for rectangular or singular matrices. Regular inverses only exist for square, full-rank matrices. The pseudoinverse extends this concept.

To be a proper pseudoinverse, **A**^† must satisfy four conditions (the Penrose conditions):

1. **A A**^† **A** = **A**
2. **A**^† **A A**^† = **A**^†
3. (**A A**^†)^H = **A A**^†
4. (**A**^† **A**)^H = **A**^† **A**

These ensure **A**^† gives the minimum norm solution when multiple solutions exist. But how do we actually compute it when **A** is rank deficient?

## Computing the Pseudoinverse via SVD

Enter the Singular Value Decomposition (SVD). It's one of the most powerful tools in numerical linear algebra, and it gives us a direct way to compute the pseudoinverse even when **A** is rank deficient.

Here's the idea: every matrix **A** ∈ ℝ^(m×n) can be decomposed as:

$$
\mathbf{A} = \mathbf{U} \Sigma \mathbf{V}^T
$$

where:
- **U** ∈ ℝ^(m×m) is orthogonal (its columns are orthonormal)
- **V** ∈ ℝ^(n×n) is orthogonal (its columns are orthonormal)
- Σ ∈ ℝ^(m×n) is diagonal with structure:

$$
\Sigma = \begin{bmatrix}
\Sigma_r & 0 \\
0 & 0
\end{bmatrix}
$$

where Σ_r = diag(σ₁, σ₂, ..., σ_r) with σ₁ ≥ σ₂ ≥ ... ≥ σ_r > 0.

The values σᵢ are the **singular values**. The number of non-zero singular values equals the rank of **A**. They tell you how much the matrix stretches space in each direction.

Now here's the elegant part. Using SVD, the pseudoinverse is simply:

$$
\mathbf{A}^\dagger = \mathbf{V}\Sigma^\dagger\mathbf{U}^T
$$

where

$$
\Sigma^\dagger = \begin{bmatrix}
\Sigma_r^{-1} & 0 \\
0 & 0
\end{bmatrix}
$$

We invert only the non-zero singular values. The zeros stay zero. This elegantly handles rank deficiency: we can't divide by zero, so we don't.

**Special case:** When **A** is square and full rank (rank(**A**) = m = n), then **A**^† = **A**^(-1). The pseudoinverse becomes the regular inverse.

## The Condition Number: When Can You Trust Your Solution?

Here's an uncomfortable truth: just because you can compute a solution doesn't mean you should trust it.

Computing **A**^T**A** for the normal equations squares the condition number of **A**. This amplifies numerical errors. Small uncertainties in your measurements can explode into huge errors in your solution. SVD avoids forming **A**^T**A**, which is why it's often more reliable.

But what is this "condition number" anyway?

The condition number measures how sensitive your solution is to tiny changes in the input:

$$
\kappa(\mathbf{A}) = \frac{\max_{\|\mathbf{x}\| = 1} \|\mathbf{A}\mathbf{x}\|}{\min_{\|\mathbf{x}\| = 1} \|\mathbf{A}\mathbf{x}\|}
$$

For the 2-norm, this has a beautiful interpretation using singular values:

$$
\kappa_2(\mathbf{A}) = \frac{\sigma_{\max}}{\sigma_{\min}} = \frac{\sigma_1}{\sigma_r}
$$

It's the ratio of the largest to smallest singular value. A large condition number means some directions get stretched way more than others. Your matrix is nearly singular in some direction.

**What this means in practice:**
- κ(**A**) ≈ 10^k → lose about k digits of accuracy in your answer
- κ(**A**) < 100 → well-conditioned, trust your solution
- κ(**A**) > 10^10 → ill-conditioned, be very suspicious

Imagine you're estimating channel coefficients in a communication system. Your measurement matrix has κ(**A**) = 10^8. Even if your sensor is accurate to 12 decimal places, your estimated coefficients are only good to about 4 decimal places. The remaining 8 digits? Amplified noise.

What do you do? Use **truncated SVD**: throw away the smallest singular values when computing **A**^†. You're deliberately ignoring the directions where **A** barely stretches space. Those directions just amplify noise anyway.

## Putting It All Together

So which method should you use? It depends on your matrix and how much you trust your data.

**If your matrix is well-conditioned and has full rank,** use the normal equations:

$$
\mathbf{x} = (\mathbf{A}^T\mathbf{A})^{-1}\mathbf{A}^T\mathbf{b}
$$

This is fast to compute. Form **A**^T**A**, invert it, done. But remember: you're squaring the condition number. Only do this when κ(**A**) is small.

**If your matrix is rank deficient or poorly conditioned,** use SVD-based pseudoinverse:

$$
\mathbf{x} = \mathbf{A}^\dagger\mathbf{b} = \mathbf{V}\Sigma^\dagger\mathbf{U}^T\mathbf{b}
$$

This costs more computationally but is much more numerically stable. The SVD reveals the true rank and handles singularities gracefully.

**If you suspect your measurements are noisy,** use truncated SVD. Drop the smallest singular values when forming **A**^†. You're trading some bias for dramatically reduced variance. The smallest singular values amplify noise anyway, so throwing them out often improves your actual solution quality even though mathematically it's "less optimal."

The least squares method underpins regression, machine learning, signal processing, and control systems. But the devil is in the numerical details. Understanding when to use which variant makes the difference between results you can trust and numerical nonsense.

## References
1. Stephen M. Kogon, Dimitris G. Manolakis, Vinay K. Ingle. "Statistical and Adaptive Signal Processing". Artech House, 2005.
2. [Proofs involving the Moore-Penrose inverse](https://en.wikipedia.org/wiki/Proofs_involving_the_Moore%E2%80%93Penrose_inverse).
3. S. Kacem. "Kompensation von frequenzselektiver I/Q-Imbalance in breitbandigen Direktmisch-Sendern". Studienarbeit 2011.
4. Mathpedia, [Methode der kleinsten Quadrate](https://mathepedia.de/Methode_der_kleinsten_Quadrate.html)